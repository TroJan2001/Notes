# **1. SameSite Cookie**

**Goal:** Prevent CSRF attacks (cross-site request forgery).

**Actors:** User, Browser, Legit Site, Attacker Site

**Flow (Strict example):**

1. **User** is logged in at `bank.com` → has `sessionid` cookie with `SameSite=Strict`.
    
2. **Attacker site** creates a form:

```html
<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="amount" value="1000">
</form>
```

3. **User** visits `evil.com` and browser auto-submits form (or user clicks button).
    
4. **Browser checks cookie policy:**
    
    - SameSite=Strict → cookie **not sent** on cross-site request.
        
5. **Legit Site** receives request **without session cookie** → rejects request.
    

✅ **Effect:** CSRF prevented.

---

# **2. CSRF Token**

**Goal:** Ensure request is legitimate even if cookies are sent.

**Actors:** User, Browser, Legit Site, Attacker Site

**Flow:**

1. **Legit Site** generates CSRF token `abc123` for user session.
    
2. **Legit Site** renders form with hidden token:

```html
<input type="hidden" name="csrf_token" value="abc123">
```

3. **User** submits legitimate request → browser sends **cookie + token**.
    
4. **Legit Site** validates token → request allowed.
    

**Attack attempt:**

1. **Attacker site** tries to submit request:

```html
<form action="https://bank.com/transfer" method="POST"></form>
```

2. **Browser** sends cookies automatically.
    
3. **Token missing or wrong** → **Legit Site rejects request**.
    

✅ **Effect:** CSRF blocked.

**Difference from SameSite:**

- Token works even if attacker tricks user with cross-site request.
    
- SameSite relies on browser blocking cookie; token works server-side.
    

---

# **3. CORS (Access-Control-Allow-Origin)**

**Goal:** Prevent attacker site from reading sensitive responses via JS.

**Actors:** User, Browser, Legit Site, Attacker Site

**Flow:**

1. **User** is logged into `bank.com`.
    
2. **Attacker site** runs JS:

```javascript
fetch('https://bank.com/user/profile')
  .then(res => res.json())
  .then(console.log)
```    

1. **Browser sends request** to `bank.com` (cookie included if present). ✅

2. **Legit Site** responds:
    
    - If `Access-Control-Allow-Origin: https://evil.com` → browser allows JS to read response.
        
    - If `Access-Control-Allow-Origin: https://bank.com` → browser **blocks JS from reading response**.
        
3. **Request still reaches server**, but **data exfiltration is blocked** if CORS misconfigured.
    

✅ **Effect:** Sensitive data not leaked to malicious JS.

---

# **4. HttpOnly Cookie**

**Goal:** Prevent JS from stealing session cookies.

**Actors:** User, Browser, Attacker Script, Legit Site

**Flow:**

1. **User** logged into `bank.com`. Cookie: `HttpOnly`.
    
2. **Attacker injects JS** via XSS:

```javascript
console.log(document.cookie)
```

1. **Browser** checks cookie flags → JS **cannot access HttpOnly cookie**.
    
2. **Attacker** cannot steal session.
    

✅ **Effect:** Stops session theft via XSS.

---

# **5. Secure Cookie**

**Goal:** Prevent cookie theft via HTTP requests.

**Actors:** User, Browser, Network (MITM), Legit Site, Attacker

**Flow:**

1. **User** visits `bank.com` over HTTPS → cookie `Secure`.
    
2. **Attacker** tries MITM via HTTP (`http://bank.com`).
    
3. **Browser** refuses to send cookie over HTTP.
    
4. **Attacker** cannot steal cookie over insecure channel.
    

✅ **Effect:** Prevents MITM cookie theft.

---

# **6. Content Security Policy (CSP)**

**Goal:** Prevent XSS / inline script execution.

**Actors:** User, Browser, Attacker Script, Legit Site

**Flow:**

1. **Legit Site** sets CSP header:

```http
Content-Security-Policy: script-src 'self'
```

1. **User’s browser** loads page.
    
2. **Attacker injects script** via form or comment.
    
3. **Browser** executes CSP rules → **rejects external/inline scripts**.
    
4. Attack code does **not execute**, so no data stolen.
    

✅ **Effect:** Blocks XSS execution.

---

# **7. X-Frame-Options**

**Goal:** Prevent clickjacking.

**Actors:** User, Browser, Attacker Site, Legit Site

**Flow:**

1. **Legit Site** sets header:

```http
X-Frame-Options: DENY
```

2. **Attacker Site** tries to embed page in iframe.
    
3. **Browser** refuses → frame blocked.
    
4. **User** cannot be tricked into clicking hidden buttons.
    

✅ **Effect:** Clickjacking blocked.

---

# **8. X-Content-Type-Options**

**Goal:** Prevent MIME sniffing.

**Actors:** User, Browser, Legit Site, Attacker File

**Flow:**

1. **Legit Site** serves file:

```http
X-Content-Type-Options: nosniff
Content-Type: text/plain
```

2. **Browser** tries to execute as JS → blocked.
    
3. **Attacker** cannot trick browser into executing malicious file with wrong MIME type.
    

✅ **Effect:** Blocks malicious script execution.

---

# **9. HSTS (Strict-Transport-Security)**

**Goal:** Force HTTPS.

**Actors:** User, Browser, Legit Site, MITM

**Flow:**

1. **Legit Site** sends header:

```http
Strict-Transport-Security: max-age=31536000; includeSubDomains
```

2. **User browser** remembers site must use HTTPS.
    
3. **User** types `http://bank.com` → browser auto-upgrades to `https://bank.com`.
    
4. **MITM attacker** cannot intercept traffic over HTTP.
    

✅ **Effect:** Prevents downgrade/MITM attacks.

|Mechanism|Who blocks it|What is blocked|Notes|
|---|---|---|---|
|SameSite|Browser|Cookie not sent cross-site|CSRF prevention|
|CSRF Token|Server|Request rejected|Server-level CSRF protection|
|CORS|Browser|JS cannot read response|Protects data exfiltration|
|HttpOnly|Browser|JS cannot read cookie|Stops XSS session theft|
|Secure|Browser|Cookie not sent over HTTP|Stops MITM cookie theft|
|CSP|Browser|Malicious script execution|Stops XSS|
|X-Frame-Options|Browser|Page cannot be framed|Stops clickjacking|
|X-Content-Type-Options|Browser|Misinterpreted file execution|Stops malicious scripts|
|HSTS|Browser|HTTP downgraded requests|Stops MITM / downgrade